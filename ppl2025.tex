\documentclass[japanese]{jssst_ppl}
\usepackage{geometry}
\usepackage{amsmath,amssymb, amsfonts, latexsym, mathtools}
\usepackage{minted}
\usepackage[all]{xy}
\usepackage{amsthm}
\usepackage{stmaryrd}
\usepackage{natbib}
%\usepackage{enumitem}
\usepackage[svgnames]{xcolor}
\usepackage{here}
\usepackage[inline]{enumitem}
\usepackage{url}

\newcommand{\mycite}[2]{[\citet{#1}, Theorem #2]}

\definecolor{bg}{rgb}{.9, .9, .9}
\theoremstyle{definition}
\newtheorem{theorem}{定理}
\newtheorem*{theorem*}{定理}
\newtheorem{definition}[theorem]{定義}
\newtheorem*{definition*}{定義}
\newtheorem{example}[theorem]{例}
\newtheorem*{example*}{例}

\def\coqin#1{\text{\mintinline[escapeinside=||]{ssr}{#1}}}



%\renewcommand{\baselinestretch}{1.5}

\newcommand{\bind}{\rm{bind}}
\newcommand{\ret}{\rm{return}}
\newcommand{\binds}{ \gg = }

\title{Delayモナドを用いた一般再帰関数に対する等式変形による検証}
\author{川上　竜司, ジャック・ガリグ, 才川 隆文}
\inst{ 名古屋大学多元数理学研究科\\
  \texttt{ \{ryuji.kawakami.c3, garrigue\}@math.nagoya-u.ac.jp, tscompor@gmail.com}}
\begin{document}
\maketitle
\begin{abstract}
  CoqのライブラリMonaeは、モナディック等式変形を用いてプログラムの計算効果に関する
  検証を可能にする。現在Monaeでは、状態モナドや確率モナドなど、様々なモナドを
  サポートすることで多様なプログラムを扱うことができるが、構造的でない再帰関数
  の扱いが難しい。一方で、余帰納的に定義されるDelayモナド
  を用いると一般再帰関数を表現できることが知られている。
  本研究では、Delayモナドに対するwhileを用いた適切なインターフェイスを定義し、
  その健全性を形式的に証明することで、Monaeを用いた一般再帰関数に対する検証を可能にした。
  また、モナドトランスフォーマーを用いて他のモナドと組み合わせることで、計算効果を含みうるより
  一般的なプログラムに対するMonaeを用いた検証を可能にする。
\end{abstract}

\section{初めに}
純粋関数型プログラムはその参照等価性としての性質から、等式変形による検証に適している。
さらには、モナドと呼ばれる構造を用いることで、計算効果を表すことができ、Haskellをはじめとした
様々な関数型プログラミング言語において採用されている。
\cite{ddd}らは、モナドの持つ代数的な性質に着目し、それぞれのモナドのインターフェイスを満たす等式の
集まりとして定義することで、計算効果の持つプログラムに関する等式変形による検証、モナディック等式変形を
提案した。
%ここまででok 結構ぶつ切りでいいきがする それぞれの要素かんのつながりというよりかは用語の説明？
%モナドトランスフォーマーもしくはtyped store monadについて書く？　モナドとの組み合わせではそこが一つの目標だから結論としてわかりやすい
%subsectionに分ける必要ない？やっぱ話の流れは欲しい

\subsection{Monae}
%interface modelからなること、ssreflect? hierarchy builder
%モジュラーな証明を可能にしている
Monae\cite{ddd}は、定理証明支援系Coqでモナディック等式変形を用いた検証を可能にするツールである。
Monaeは、モナディック等式変形を行うための等式の集まりであるインターフェイスと、その健全性を保証するモデルから構成される。
Coqを用いることで、検証の正しさを保証し、Mathcomp/ssreflectを用いた簡潔な証明が可能になる。
Monaeでは、モナディック等式変形で必要となるインターフェイスの階層をHierarchy builderライブラリ\cite{ddd}
を用いて実装することで、複数のモナドの組み合わせや、再利用可能な構造的な証明を行うことができる。
%現在もなえでできること？
%つまり、modularな証明ができるということ



\subsection{構造的でない再帰関数の扱い}
定理証明支援系では無矛盾性の保証のため、停止しない関数を定義できない。CoqのFixpointコマンドでは、
引数の持つ整礎な順序関係が構文的に自明な構造的再帰関数については定義できる。%構造的再帰関数の定義は？
そうでないときは、Equationコマンドなどを用いて引数が整礎な順序関係を持ち減少する値であることの証明とともに定義する
必要がある。
しかし、非決定性を持つquicksortなどのプログラムでは、引数が減少することを証明することはできず、\cite{ddd}では、
dependently-typed assertionと呼ばれる方法を用いる工夫が行われている。
また、停止性の未解決なコラッツ関数などは定義することができない。
%satisfy syntactical constraints on a special argument called the decreasing argument

%どのような関数がCoqでは定義できて、どのような関数が定義できないか monaeの論文にそのことについて言及あり
%interaction treeをそこまで全面的に出さなくても良い？
\subsection{CoInductive typeを用いた一般再帰の定義}
一方で、定理証明支援系で構造的でない再帰関数を扱う他の方法として、余帰納的定義を用いる手法がある。
余帰納的定義は無限長のリストであるストリームなどの無限個のコンストラクターを持つデータを定義する際に用いられる。
Coqでは、生産性条件を満たす限り、無限にコンストラクターを適用することができるため、それを用いて無条件な再帰呼び出しを
行うことで、構造的でない再帰関数を扱うことができる。それらの関数は、戻り値が余帰納的データとなってしまうが、停止性の
証明なしに定義することができる。\\
Delayモナド\cite{ddd}を用いるとそういった余再帰的な関数呼び出しを行うプログラムをモナディックプログラムとして表すこと
ができる。したがって、本研究では、Delayモナドに対する適切なインターフェイスを定義することでMonaeを用いた停止性の
保証できない一般再帰関数に対する検証を試みた。


%CoInductive typeを用いた一般再帰の定義のinteraction treeを全面に出した説明
\subsection{interaction treeにおける構造的でない再帰関数の扱い}




%再帰の証明なしに扱う方法として、coinductive typeがある
%cofixpointを使ったcolattzs関数の定義 interaction treeでは、、、
%delayモナドについて

\subsection{Complete elgot monad}
%fixpointEのlawを図式で書いて説明。特にダガーoperationについても　coinductive resumption monadについても
Delayモナドのインターフェイスを定義するにあたって、complete elgot monadを参考にした。
complete elogot monadは、代数的に再帰構造を扱うiteration theory\cite{ddd}に対応しており、
イテレーションと呼ばれる、各$f : X \rightarrow M (Y + X)$を$f^{\dagger} : X \rightarrow M Y$に対応させるオペレーター
$\_^{\dagger}$をもち4つの公理を満たすモナドとして定義される。\\
例えば、等式fixpointは次の可換図式で表される。
\xymatrixcolsep{2.5cm}
\[
  \xymatrix{
  X \ar[r]^{f^{\dagger}} \ar[d]^{f} & M A  \\
  M (A + X) \ar[r]^{M[\eta_A, f^{\dagger}]}  & M^2 A \ar[u]^{\mu_A}
  }
\]

この規則は関数fがAの値を返すまで繰り返し計算を行った結果が、$f^{\dagger}$に等しいことを表している。\\

Delayモナドは
%The Delay Monad and Restriction Categories
有限回の計算ステップを無視する同一視を行うことでcomplete elgot monadとなることが知られている\cite{?}。




\subsection{Typed store monad transformer}



\iffalse
  プログラムの副作用をモナドを用いて表す手法は、Haskellをはじめとした様々な関数型プログラミング言語
  において採用されている。モナディック等式変形では、それぞれのモナドに対し、等式の集合を含むインターフェイスを
  定義することで、副作用を含むプログラムに対する等式変形による検証を行うことができる。\\
  ライブラリMonaeを用いることでモナディック等式変形を定理証明支援系Coqで行うことができる。
  Monaeを用いることで証明の正しさを保証できるだけでなく、それぞれのモナドや関手の間の階層を定義することで
  再利用可能な証明やssreflectを用いた簡潔な証明を記述することができる。\\
  Monaeでは現在、状態モナドや確率モナドなど様々なモナドをサポートすることで多様なプログラムに関する
  検証が可能であるが、一方でCoqの無矛盾性を保証するため、停止性の非自明な関数については扱うことが難しい。
  そこで、本研究では、余帰納的に定義されるDelayモナドをMonaeに実装することで、
  Coqを用いた一般再帰関数の等式変形による検証を可能にした。

  \subsection{Delayモナドとは}

  Delayモナドとは、\cite{ddd}で導入されたモナドである。余帰納的に定義されることで、
  停止しない関数の計算を表現することが可能である。\\
  Delayモナドを構成する関手Delayは、(A:Type) $\rightarrow$ (\text{cofixpoint} of X = A + X )
  という型を持つ関数である。
  Coqでは、Coinductive コマンドと、各最大不動点への埋め込みを表すコンストラクターDNow, DLater
  を用いて定義することができる。
  \begin{minted}[bgcolor=bg,numbers=left,xleftmargin=1.5em]{ssr}
CoInductive Delay (A : Type) : Type :=
  |DNow : A -> Delay A
  |DLater : Delay A -> Delay A.
                \end{minted}

  余帰納的に定さされるため、Delay Aの型を持つ項は、
  \begin{enumerate*}[label=\text{(\arabic*)}]
    \item \coqin{DNow a}
    \item \coqin{DNow a}に有限回\coqin{DLater}を適用した項
    \item 無限回\coqin{DLater}を適用したもの
  \end{enumerate*}
  と分別することができる。DLaterは明示的な計算ステップを
  表しているため、(2)は、値aを返す停止するような計算、(3)は停止しない計算とみなすことができる。


\fi

\subsection{本稿の貢献と構成}
本稿の貢献は以下のようにまとめられる。
\begin{itemize}
  \item Delayモナドの計算的同値性に関する規則を含むインターフェイスを定義し、その健全性を
        形式的に示すことで、一般再帰関数に関する検証をMonaeで行うことを可能にした。
  \item モナドトランスフォーマーを用いて他のモナドとの組み合わせやsetoidライブラリを用いたgeneralized rewrite tactics の利用により
        一般再帰関数に関するMonaeによる検証の有用性を高めた。
\end{itemize}

以下、2節でDelayモナドのインターフェイスの詳細ついて、3節でモナドトランスフォーマーを用いた組み合わせと
generalized rewrite tacticsについて、4節で検証の具体例について説明する。
また5節で関連研究について、6節でまとめと課題について論じる。

なお、本研究のコードは以下のulrから確認することができる。\\

\begin{center}
  \url{https://github.com/Ryuji-Kawakami/monae/tree/delaypull}
\end{center}






\section{Delayモナドのmonaeにおける実装}


\subsection{Delayモナドのモナド構造}
%COfixpointの説明？

Delayモナドのモナド構造はCoFixpointコマンドを用いて定義できる。
bindオペレーターは引数が停止する計算結果である場合のみ、その値をfに適用した値を返す、とみなすことができる。
\begin{minted}[bgcolor=bg,numbers=left,xleftmargin=1.5em]{ssr}
Let ret (a:A) := DNow a
CoFixpoint bind (m: Delay A) (f: A -> Delay B ) :=
  match m with
  |DNow a => f a
  |DLater d => DLater (bind d f)
  end.
                \end{minted}

さて、Delayモナドに付随するoperatorとして、繰り返し処理を行うwhileを定義する。
while オペレーターはDelayモナドのインターフェイスを定義するにあたって参考にした
complete elgot monadの$\dagger$オペレーターに相当し、それらに関する代数理論が
研究されているため、採用した。\\
CoFixpointコマンドを用いて定義され、右埋め込みの値\mintinline{ssr}|inr a|が値a
での繰り返しの継続、左埋め込みの値\mintinline{ssr}|inl b|が値bを戻り値とする繰り返し
の終了を表す。

\begin{minted}[bgcolor=bg,numbers=left,xleftmargin=1.5em]{ssr}
CoFixpoint while {A B} (body: A -> M (B + A)) : A -> M B :=
  fun a => (body a) >>= (fun ab => match ab with
                                   |inr a => DLater (while body a)
                                   |inl b => DNow b end).
\end{minted}


%CoFixpointに関する説明を詳しく？


\subsection{計算的同値性}
さて、ここでDelayモナドの関わる等式変形は、一般再帰関数の性質を調べるためには、不十分である。
例えば、階乗を計算する関数factをDelayモナドを用いて定義した場合、fact 3は
明示的な計算ステップDLaterを3つ含むため、DNow 6と一致しないためである。したがって、計算的な同値性を表す
関係が必要である。そこで、
有限個のDLaterを除いて等しい場合、またはどちらもDLaterが無限個続く場合に計算的に等しいとみなす関係wBisimを


\cite{ddd}と同様に次のように導入した。\\


まず、計算がある値で停止する性質をTerminateという帰納的な関係で定義する。\\
\mintinline{ssr}|Terminate d a| とは、dが計算の結果、値aを返すことである。
\begin{minted}[bgcolor=bg,numbers=left,xleftmargin=1.5em]{ssr}
Inductive Terminates A : Delay A -> A -> Prop :=
  |TDNow a : Terminates (DNow a) a
  |TDLater d a : Terminates d a -> Terminates (DLater d) a.
\end{minted}
次に、この述語を用いて、wBisimを余帰納的関係として定義する。つまり、d1,d2が有限個のDLaterを除いて
等しい場合wBTerminate d1 d2 aが成り立ち、d1,d2がどちらもDLaterが無限個続く場合は、wBLaterにより
余帰納法を用いることで、wBisim d1 d2を示すことができる。
\begin{minted}[bgcolor=bg,numbers=left,xleftmargin=1.5em]{ssr}
CoInductive wBisim A : Delay A -> Delay A -> Prop :=
  |wBTerminate d1 d2 a :
    Terminates d1 a -> Terminates d2 a -> wBisim d1 d2
  |wBLater d1 d2 : wBisim d1 d2 -> wBisim (DLater d1) (DLater d2).
\end{minted}

\subsection{余帰納法を用いた等式の証明}
ここでは、どのように余帰納法の原理を用いて、wBisimに関する性質をCoq上で示したかについて
説明する。\\
まず、余帰納法の原理とは次のような主張である。
\begin{theorem}{余帰納法の原理\\}
  X,A,B,C:集合,
  関数$F:\mathcal{P}(X) \to \mathcal{P}(X)$\\
  Fが単調であるとは、$A \subset B \implies F(A) \subset F(B)$が成り立つことである。\\
  この時、$A \subset F(A) \implies A \subset (F \ \text{の最大不動点})$
\end{theorem}
このもとで、wBisim Aの定義は、集合Xについて、
\begin{align*}
  F(X) = \{ (d_1, d_2) | \exists a \in A, \text{terminate} \ d_1 \ a \ \land \ \text{terminate} \ d_1 \ a \ \} \\
  \cup \ \{ (\text{DLater} \ d_1, \text{DLater} \  d_2) | (d_1, d_2) \in X\}
\end{align*}


で定義されるFの最大不動点として定義される。\\
Coqでは、cofixタクティックを用いて最大不動点を取ることで余帰納法を行うことができる。
例えば、cofixを用いて\mintinline{ssr}|wBisim (DLater d) d |を示した。

Fは定義より、明らかに単調である。\\
従って、余帰納法の原理より、集合 $Y = \{ (\text{DLater} \ d, d) | d \in \text{Delay} \ A \} $とおき、
$Y \subset F (Y) $が成り立つを示せばよい。Coqでは、この最大不動点Yに対応する命題をcofixで宣言することができる。\\
任意にYの要素dを取ると、定義より、$d = (\text{DLater} \ (\text{DNow} \ a), \ \text{DNow} \ a)$または、$d = (\text{DLater} (\text{DLater} \ d'), (\text{DLater} \ d'))$の二つの場合がある。\\
一つ目の場合は、terminate (DNow a) a, terminate (DLater(DNow a)) aが成り立つため、$d \in F(Y)$である。\\
二つ目の場合は、Yの定義より、$ ( \text{DLater d'}, \text{ d' } ) \in Y$である。従って$ d \in Y $である。\\
よって、$Y \subset F (Y)$ であることがわかった。\\
したがって、Coqでは、次のように証明される。
\begin{minted}[bgcolor=bg,numbers=left,xleftmargin=1.5em]{ssr}
Lemma wBisim_DLater A : forall (d : M A), wBisim (DLater d) d.
Proof.
cofix CIH => d.
case: d => [a|d'].
- apply : wBTerminate.
  + by apply/TDLater/TDNow.
  + by apply TDNow.
- apply wBLater.
by apply CIH.
Qed.
\end{minted}



%Oeq DLaterの例


\subsection{Delayモナドのインターフェイス}
以上のことを踏まえて、Delayモナドのinterfaceを表1,2,3のように定義した。\\
まず、Delayモナドのオペレイターは、繰り返し処理を行うwhileである。また、計算の等さを表す関係である、
wBisim \, $ \approx $と、それが同値関係であるという規則を導入する。\\
また、whileオペレーターに対する6つの規則を定義した。
初めの3つの規則は、再帰的処理を代数理論として扱うiteration theory\cite{iteration}、およびそれに対応するCompletely elgot monad\cite{ADAMEK20101306} の定義を参考にした。\\
fixpointEは、whileによって、繰り返す処理をすることができることを表す規則である。\\
naturalityEは、while文により行った計算結果を、次の処理に渡す場合、それは一つのwhile文により記述できることを表す。\\
codiagonalEは、連続して入れ子になったwhile文を一つのwhile文にすることができることを表す。\\
後半の3つの規則は、検証上有用であると考え導入した。\\
bindmwBはbindの引数が同じ計算結果を表しているのならば、fに渡した結果も同じ計算結果になることを表している。\\
bindfwBは同じfとgが同じ計算をするならば、bindで同じ引数を渡した結果も同じ計算結果になることを表す。\\
whilewBは、while文でその都度繰り返す処理が、計算的に等しいならば、
while文全体として等しいことを表す。\\
後半の規則については、setoid rewriteの機能を用いてより等式変形に近い形で検証が可能にした。詳細については3.2節で説明する。\\
これらの規則を用いた等式変形では、モデルにおいて、健全性を示した時のようなcoinductionを用いた証明
をする必要がなく、簡潔で直感的な検証が可能になる。

\begin{table}
  \caption{The operator and relation}
  \centering
  \begin{tabular}{|c|}
    \hline
    \coqin{while :  (A -> M(B + A)) -> A -> M B} \\
    \coqin{wBisim :  M A -> M A -> Prop}         \\
    \hline
  \end{tabular}
\end{table}

\begin{table}
  \caption{The laws of the wBisim}
  \centering
  \begin{tabular}{|l|l|}
    \hline
    \coqin{ wBisim_refl}  & \coqin{ a |\scalebox{0.8}{$\approx$}| a}                                                                       \\
    \coqin{ wBisim_sym}   & \coqin{ a |\scalebox{0.8}{$\approx$}| b -> b |\scalebox{0.8}{$\approx$}| a}                                    \\
    \coqin{ wBisim_trans} & \coqin{ a |\scalebox{0.8}{$\approx$}| b -> b |\scalebox{0.8}{$\approx$}| c -> a |\scalebox{0.8}{$\approx$}| c} \\
    \hline
  \end{tabular}
\end{table}

\begin{table}
  \caption{The laws of while}
  \centering
  \begin{tabular}{|l|l|}
    \hline
    \coqin{fixpointE }   & \coqin{while f a |\scalebox{0.8}{$\approx$}| (f a) >>= (sum_rect Ret (while f)) }                          \\
    \coqin{naturalityE } & \coqin{while f a >>= g |\scalebox{0.8}{$\approx$}|}                                                        \\
                         & \coqin{while (fun y => (f y) >>=}                                                                          \\
                         & \coqin{  (sum_rect (M |\#| inl o g) (M |\#| inr o Ret))) a}                                                \\
    \coqin{codiagonalE } & \coqin{while ((M |\#| ((sum_rect  idfun inr))) o f ) a |\scalebox{0.8}{$\approx$}|}                        \\
                         & \coqin{  while (while f) a}                                                                                \\
    \coqin{bindmwB}      & \coqin{d1 |\scalebox{0.8}{$\approx$}| d2 -> d1 >>= f |\scalebox{0.8}{$\approx$}| d2>>= f}                  \\
    \coqin{bindfwB}      & \coqin{(forall a, f a |\scalebox{0.8}{$\approx$}| g a) -> d >>= f |\scalebox{0.8}{$\approx$}| d >>= g}     \\
    %& \coqin{d >>= f |\scalebox{0.8}{$\approx$}| d >>= g}                                                        \\
    \coqin{whilewB}      & \coqin{(forall a, f a |\scalebox{0.8}{$\approx$}| g a) -> while f a |\scalebox{0.8}{$\approx$}| while g a} \\
    %& \coqin{while f a |\scalebox{0.8}{$\approx$}| while g a}                                   \\
    \hline
  \end{tabular}
\end{table}


\iffalse
  \begin{minted}[escapeinside=||]{ssr}
  HB.mixin Record isMonadDelay (M : UU0 -> UU0) of Monad M := {
  while : forall {A B : UU0}, (A -> M(B + A)%type) -> A ->M B;
  wBisim: forall {A : UU0}, M A -> M A -> Prop;
  wBisim_refl: forall A (a: M A), wBisim a a;
  wBisim_sym: forall A (a b: M A), wBisim a b -> wBisim b a;
  wBisim_trans: forall A (a b c: M A), wBisim a b -> wBisim b c -> wBisim a c;
  fixpointE: forall (A B : UU0) (f: A -> M (B + A)%type) (a: A),
  wBisim (while f a) ((f a) >>= (sum_rect (fun => M B ) (@ret M B) (while f)));
  naturalityE: forall (A B C : UU0) (f: A -> M (B + A)%type) (g: B -> M C) (a: A),
  wBisim ((while f a) >>= g)(while (fun y => (f y) >>= (sum_rect (fun => M (C + A)%type) (M # inl \o g) (M # inr \o (@ret M A )) ) ) a);
  codiagonalE:forall (A B : UU0) (f: A -> M ((B + A) + A)%type) (a: A),
  wBisim (while ((M # ((sum_rect (fun => (B + A)%type) idfun inr)))  \o f ) a) (while (while f) a);
  bindmwB: forall (A B: UU0) (f: A -> M B)(d1 d2: M A),
  wBisim d1 d2 -> wBisim (d1 >>= f) (d2>>= f);
  bindfwB: forall (A B: UU0) (f g: A -> M B)(d: M A),
  (forall a, wBisim (f a) (g a)) -> wBisim (d >>= f) (d >>= g);
  whilewB: forall (A B : UU0) (f g: A -> M ((B + A))%type) (a: A),
  (forall a, wBisim (f a) (g a)) -> wBisim (while f a) (while g a);
  }.
        \end{minted}

\fi

\section{Delayモナドと他のモナドの組み合わせ}
Delayモナドのinterfaceを定義することで、一般再帰関数に対する検証が可能になった。
この手法をより多くの関数へ適用するためには、Delayモナドを他のモナドと組み合わせることにより
複雑な副作用を表現する必要がある。そこで、\cite{ddd}においてサポートされたモナドトランスフォーマーを
用いて他のモナドとの組み合わせを行った。また
等式変形による検証に近い形で検証を可能にするため、setoid rewrite を用いてより証明を簡潔にする工夫を
行った。


\iffalse
  \subsubsection{モナドトランスフォーマーの定義}
  %この章いらないかも
  (論文の名前)にしたがってモナドトランスフォーマーの定義を述べる。


  \begin{definition}
    M,Nがモナドであるとする。この時、自然変換$\xi: M \to N$がモナド射であるとは、$\xi$が以下の2つの等式を満たす時のことである。
    \begin{center}
      $ \ret_A^N a = \xi_A (\ret_A^M \, a)$ \\
      $ \xi_B \,(m \binds_M f) = \xi_A m \binds_N \xi_B \cdot f $ \\
    \end{center}
  \end{definition}

  \begin{definition}
    モナドトランスフォーマーMTは、4つの変換子からなる組$(\text{T},\ret^T,\bind^T,lift^T)$であり、
    任意のモナドMに対して、
    \begin{itemize}
      \item $(\text{TM}, \ret^T(ret, \bind), bind^T(\ret,\bind))$がモナド
      \item $\text{lift}^\text{T}(\ret,\bind)$がMからTMへのモナド射となる
    \end{itemize}
    を満たすものである。
  \end{definition}

\fi
\subsubsection{状態モナドトランスフォーマーとの組み合わせ}
状態モナドトランスフォーマーstateTは次のように定義される。\\
Sが状態、Mが変換前の関手、としてMS,retS,bindSがそれぞれ変換後の関手、return, bindである。

\begin{minted}[bgcolor=bg,numbers=left,xleftmargin=1.5em]{ssr}
Let MS := fun A => S -> M (A * S).
Let retS := fun A => curry Ret.
Let bindS m f := fun s => m s >>= uncurry f.
Let liftS m := fun s => m >>= (fun x => Ret (x, s)).
        \end{minted}

さて、stateTにより状態モナドと組み合わせるためには、delayモナドがstateTで変換後、delayモナドであることを示す
必要がある。そこで、\cite{d}を参考に次のようにwhileDSとwBisimDSを定義した。関数dist1は、分配法則を表し、型を合わせるために定義した。
\iffalse
  そこで、次の定理を用いた。\\

  %monad for behaviorの定理をかく
  %ここもなくてもよい。参考にした論文のい挙げる
  随伴にcurryとuncurryを

  特に状態モナドが随伴$(- \otimes A) \vdash (A \rightarrow - )$から導出されるため次のように
  while operatorとwBisimを定義した。関数dist1は、分配法則を表し、型を合わせるために定義した。
\fi

\begin{minted}[bgcolor=bg,numbers=left,xleftmargin=1.5em]{ssr}
M:delayMonad
Let DS := MS M
Let whileDS (body : X -> DS (Y + X)) :=
  curry (while (M # dist1 o uncurry body)).

Let wBisimDS (ds1 ds2 : DS A) : Prop :=
  forall s : S, wBisim (ds1 s) (ds2 s).
          \end{minted}




\subsubsection{例外モナドトランスフォーマーとの組み合わせ}
例外モナドトランスフォーマーexceptTは次のように定義される。\\
Zが例外の集合、Mが変換前の関手、としてMX,retX,bindXがそれぞれ変換後の関手、return, bindである。

\begin{minted}[bgcolor=bg,numbers=left,xleftmargin=1.5em]{ssr}
Let MX := fun X => M (Z + X).
Let retX : idfun --> MX := fun X x => Ret (inr x).

Let bindX t f :=
  t >>= fun c => match c with inl z => Ret (inl z) | inr x => f x end.
        \end{minted}
stateTの場合と同様に、delayモナドがexceptTで変換後delayモナドであることを示す必要がある。
そこで、次のように定義した。
関数DEAを合成することでにより、エラーが発生した際\coqin{inl (inl u)}を返すことで、繰り返しを終了する。

\begin{minted}[bgcolor=bg,numbers=left,xleftmargin=1.5em]{ssr}
M: delayMonad
Let DE := MX unit M.
Let whileDE (body : A -> DE (B + A)) : DE B := while (DEA o body)
Let wBisimDE (d1 d2 : DE A) := wBisim d1 d2.
        \end{minted}

\subsubsection{型付きストアモナドとの組み合わせ}
このモナドcoqgenで変換したocamlのコードを検証する際、
はML のreferenceを表すためにmonaeに導入された。\\
Mが変換前のモナドを表す。
このモナドはexceptTとstateTの合成で定義される。
型と値のレコードbindingのリストを状態として使うことで、型付きストアを表しています。
また参照を扱うためのoperatorであるcnew, cget, cputを持つ。
\begin{minted}[bgcolor=bg,numbers=left,xleftmargin=1.5em]{ssr}
Record binding :=
  mkbind { bind_type : ml_type; bind_val : coq_type bind_type }.

Let DTS := MS (seq binding) (MX unit M).
        \end{minted}

exceptT、stateTがdelayモナドの構造を保つため、型付きストアモナドトランスフォーマーとの組み合わせ
も可能であることがわかった。このモナドを用いることで、図のような表現が可能となった。

\begin{minted}[bgcolor=bg,numbers=left,xleftmargin=1.5em]{ssr}
Let factdts_aux_body r n : M (unit + nat) :=
  do v <- cget r;
     match n with
     |O => do _ <- cput r v; Ret (inl tt)
     |S m => do _ <- cput r (n * v); Ret (inr m)
     end.
Let factdts_aux n r := while (factdts_aux_body r) n.
Let factdts n := do r <- cnew ml_int 1;
                 do _ <- factdts_aux n r ;
                 do v <- cget r; Ret v.
            \end{minted}

\section{setoid rewriteを用いたgeneralized rewriting in coq}
Setoidライブラリは、ユーザーが独自に定義した関係に対するrewrite tacticの使用を
可能にする。そこで、wBisimに対するrewrite tacticsの使用を可能にすることで、monaeを
用いた他の検証と同様なrewrite tacticsを中心とした証明を可能にした。\\

まずは、wBisimとwBisimに関する関数の外延的な等さであるwBisimextをパラメトリック同値関係として
定義した。
\begin{minted}[escapeinside=||,bgcolor=bg,numbers=left,xleftmargin=1.5em]{ssr}
Add Parametric Relation A : (M A) (@wBisim M A)
  reflexivity proved by (@wBisim_refl M A)
  symmetry proved by (@wBisim_sym M A)
  transitivity proved by (@wBisim_trans M A)
  as wBisim_rel.
        \end{minted}
この定義により、インターフェイスの規則であるbindmwBとbindfwB、whilewBがそれぞれ
関数bind, whileがこれらの同値関係を保つことを表している。したがって、bind,whileを
Parametric morphismとして定義した。
\begin{minted}[bgcolor=bg,numbers=left,xleftmargin=1.5em]{ssr}
Add Parametric Morphism A B : bind
  with signature (@wBisim M A) ==>
    (pointwise_relation A (@wBisim M B)) ==> (@wBisim M B) as bindmor.

Add Parametric Morphism A B : while
  with signature (pointwise_relation A (@wBisim M (B + A))) ==>
    @eq A ==> (@wBisim M B ) as whilemor.
        \end{minted}
これにより次のような証明が可能になる。

%証明の具体例


\section{検証の具体例}
ここでは、Delayモナドのinterfaceを用いることでどのような検証が
可能になったかを紹介する。

\subsection{Monadの満たす等式}
モナドは、bindとreturnを持ち、表4の等式を満たす型クラスとして
特徴づけられる。


\begin{table}[b]
  \caption{The laws of the monad}
  \centering
  \begin{tabular}{|l|l|}
    \hline
    \coqin{bindretf} & \coqin{Ret a >>= f = f a}                            \\
    \coqin{bindmret} & \coqin{m >>= Ret = Ret}                              \\
    \coqin{bindA}    & \coqin{(m >>= f) >>= g = m >>= (fun x => f x >>= g)} \\
    \hline
  \end{tabular}
\end{table}

\iffalse
  \begin{minted}{ssr}
  M : monad
  Lemma bindretf (A B: UU0) (a : A) (f : A -> M B): Ret a >>= f = f a.
  Lemma bindmret (A B: UU0) (m : M A) : m >>= Ret = Ret.
  Lemma bindA (A B C: UU0) (m: M A) (f: A -> M B)(g: B -> F C):
    (m >>= f) >>= g = m >>= (fun x => f x >>= g).
\end{minted}

\fi





monaeでは、各Monadをインスタンス化した際にこれらの等式と関連する補題を
用いることができるようになる。
特にここでは、表4の等式を用いて検証する。





\subsection{マッカーシーの91関数に対する検証}
マッカーシーの91関数mc91は、再帰的に定義される関数であり、$m \leq 101$の時、
必ず91を返すという性質をもつ関数である。

\begin{minted}[bgcolor=bg,numbers=left,xleftmargin=1.5em]{ocaml}
let rec mc91 m = if 100 < m then m - 10 else mc91 (mc91 (m+11))
   \end{minted}

$m \leq 100$の時、11足した値で二重に再帰するため、停止性がCoqでは直ちに
判定できない関数である。\\
したがって、mc91関数をdelayモナドを用いて表し、自然数$m \leq 100$について
91が戻り値となることを示した。\\
まず、while operatorを用いてmc91関数を用いて表す。残っている再帰の深さd、mが計算している値である。



\begin{minted}[bgcolor=bg,numbers=left,xleftmargin=1.5em]{ssr}
Let mc91_body nm :=
    match nm with (n, m) =>
    if n==0 then ret (inl m)
            else if m > 100
                 then ret (inr(n.-1, m - 10))
                 else ret (inr(n.+1, m + 11))
    end.
Let mc91 n m := while mc91_body (n.+1, m).
    \end{minted}

mc91関数が91を返すことを示す際、本質的な性質は、補題mc91succEである。
この補題と、\coqin{mc91 n 101 |$\approx$| Ret 91}であることと、
$ k =  90 - m $に関する帰納法により従う。



\begin{minted}[bgcolor=bg,numbers=left,xleftmargin=1.5em, escapeinside=||]{ssr}
Lemma mc91succE n m : 90 <= m < 101 -> mc91 n m |\scalebox{0.8}{$\approx$}| mc91 n (m.+1).
\end{minted}

さて、この補題を図1のように示した。
%《の中をrewriteを使った表記に変える



%| $\llbracket$ | rewrite \mc91 |$\rrbracket$|

\begin{figure}[H]
  \centering

  \begin{minted}[escapeinside=||,mathescape = true, frame = single]{ssr}
mc91 n m
 |$\llbracket$| rewrite /mc91. (*definition of mc91*) |$\rrbracket$|
 | \scalebox{0.8}{$\approx$} | while mc91_body (n.+1, m)
 |$\llbracket$| rewrite fixpointE. |$\rrbracket$|
 | \scalebox{0.8}{$\approx$} | (if 100 < m then Ret (inr (n, m - 10))
              else Ret (inr (n.+2, m + 11))) >>=
                   sum_rect Ret (while mc91_body)
 |$\llbracket$| rewrite ifN //. (* $ m \leq 100$ *)|$\rrbracket$|
  |\scalebox{0.8}{$\approx$}| Ret (inr (n.+2, m + 11)) >>= sum_rect Ret (while mc91_body)
 |$\llbracket$| rewrite bindretf /= fixpointE /=. |$\rrbracket$|
  |\scalebox{0.8}{$\approx$}| while mc91_body (n.+2, m + 1)
 |$\llbracket$| rewrite bindretf fixpointE /=. |$\rrbracket$|
  |\scalebox{0.8}{$\approx$}| (if 100 < m + 11
      then Ret (inr (n.+1, m + 11 - 10))
      else Ret (inr (n.+3, m + 11 + 11))) >>=
          sum_rect Ret (while mc91_body)
  |$\llbracket$| rewrite ltn_add2r ifT //. (* $90 \leq m \implies 100 < m + 11 $ *) |$\rrbracket$|
  Ret (inr (n.+1, m + 11 - 10)) >>= sum_rect Ret (while mc91_body)
 |$\llbracket$| rewrite  bindretf fixpointE /= fixpointE. |$\rrbracket$|
  |\scalebox{0.8}{$\approx$}|  while mc91_body (n.+1, m + 11 - 10) = mc91 n (m+1)

    \end{minted}


  \caption{proof of mc91 }
\end{figure}


\iffalse
  \begin{minted}[escapeinside=||]{ssr}
    mc91 n m
   |《 definition of mc91 》|

   | \scalebox{0.8}{$\approx$} | while (fun nm : nat * nat =>
    let (n0, m0) := nm in if n0 == 0 then Ret (inl m0)
                                     else if 100 < m0
                                          then Ret (inr (n0.-1, m0 - 10))
                                          else Ret (inr (n0.+1, m0 + 11))) (n.+1, m)
   |《 fixpointE 》|
   | \scalebox{0.8}{$\approx$} | (if 100 < m then Ret (inr (n, m - 10))
                else Ret (inr (n.+2, m + 11))) >>= sum_rect (fun=> M nat) Ret (while mc91_body)
   |《 $m < 101$ 》|
    |\scalebox{0.8}{$\approx$}| Ret (inr (n.+2, m + 11)) >>= sum_rect (fun=> M nat) Ret (while mc91_body)
   |《 Monad law: Ret a >>= f = f a 》|
    |\scalebox{0.8}{$\approx$}| while mc91_body (n.+2, m + 1)
   |《 definition of mc91,fixpointE 》|
    |\scalebox{0.8}{$\approx$}| (if 100 < m + 11
        then Ret (inr (n.+1, m + 11 - 10))
        else Ret (inr (n.+3, m + 11 + 11))) >>= sum_rect (fun=> M nat) Ret (while mc91_body)
   |《 $90 \leq m \implies 100 < m + 11$, Monad law  》|
    |\scalebox{0.8}{$\approx$}|  while mc91_body (n.+1, m + 11 - 10) = mc91 n (m+1)

      \end{minted}

\fi

\subsection{状態を用いたfactorial}
3.1.3節で定義したfactdtsについて、実際に階乗を計算していること
を検証する。つまり次factnと計算として一致することを示した。

\begin{minted}[bgcolor=bg,numbers=left,xleftmargin=1.5em]{ssr}
Fixpoint fact n := match n with |O => 1 |m.+1 => n * fact m end.
Let factn n := do r <- cnew ml_int (fact n);
               do v <- cget r; @ret M _ v.
\end{minted}

ここでは、factdtsのwhileを用いた部分fact\_auxがfactを用いた形に書き換えられることについて
取り上げる。この書き換えと、型付きストアモナドの等式を用いることで、factnに一致することが従う。
証明はnに関する帰納法により図2,3のように行った。


\begin{figure}[H]
  \centering
  \begin{minted}[escapeinside=~~, frame = single]{ssr}
    while (factdts_aux_body r) 0
    ~$\llbracket$~ rewrite fixpointE/= !bindA. ~$\rrbracket$~
    cget r >>=
    (fun s =>
     (cput r s >> Ret (inl tt)) >>=
     sum_rect Ret (while (factdts_aux_body r)))
    ~$\llbracket$~ rewrite bindfwB => [ |s]; last first. (* rewrite under binder *) ~$\rrbracket$~
     (cput r s >> Ret (inl tt)) >>=
              sum_rect Ret (while (factdts_aux_body r))
    ~$\llbracket$~ rewrite bindA bindretf/= -{1}(mul1n s). ~$\rrbracket$~ 
     cput r (1 * s) >> Ret tt
    ~$\llbracket$~ by []. (* over *) ~$\rrbracket$~
     cget r >>= (fun s => cput r (1 * s) >> Ret tt)
    = cget r >>= (fun s => cput r (fact 0 * s) >> Ret tt)
    \end{minted}

  \iffalse
  \fi
  \caption{proof of factn if n =  0 }
\end{figure}


\begin{figure}[H]
  \centering
  \begin{minted}[escapeinside=~~, frame = single]{ssr}
    while (factdts_aux_body r) n'.+1
   ~$\llbracket$~ rewrite fixpointE/= !bindA. ~$\rrbracket$~
 cget r >>=
 (fun s =>
  (cput r (n'.+1 * s) >> Ret (inr n')) >>=
  sum_rect Ret (while (factdts_aux_body r)))
   ~$\llbracket$~ rewrite bindfwB => [ |s]; last first. (* rewrite under binder *) ~$\rrbracket$~
  (cput r (n'.+1 * s) >> Ret (inr n')) >>=
  sum_rect Ret (while (factdts_aux_body r))
  ~$\llbracket$~ rewrite bindA bindretf/=. ~$\rrbracket$~
  cput r (n'.+1 * s) >> (cget r >>=
         (fun s => cput r (fact n' * s) >> Ret tt))
  ~$\llbracket$~ rewrite IH -bindA -bindA. (*rewrite using induction hypothese IH*)~$\rrbracket$~
  (cput r (n'.+1 * s) >> (cget r >>= (fun s => cput r (fact n' * s))))
  ~$\llbracket$~ rewrite cputget cputput. (*laws for cput and cget *) ~$\rrbracket$~
  cput r (n'.+1 * fact n' * s) >> Ret tt
  ~$\llbracket$~ by []. (* over *) ~$\rrbracket$~
  cget r >>= (fun s => cput r (n'.+1 * fact n' * s) >> Ret tt)
  = cget r >>= (fun s => cput r (fact n'.+1 * s) >> Ret tt)

       \end{minted}

  \iffalse
    \begin{minted}[escapeinside=||, frame = single]{ssr}
    while (factdts_aux_body r) n'.+1
 |《 fixpointE 》|
 cget r >>=
 (fun s : coq_type N ml_int =>
  (cput r (n'.+1 * s) >> Ret (inr n')) >>=
  sum_rect Ret (while (factdts_aux_body r)))
  |《 rewrite under cget r >>= by bindfwB 》|
  (cput r (n'.+1 * a) >> Ret (inr n')) >>=
  sum_rect Ret (while (factdts_aux_body r))
  |《 fixpointE 》|
  cput r (n'.+1 * a) >> (cget r >>=
         (fun s : coq_type N ml_int => cput r (fact n' * s) >> Ret tt))
  |《 fixpointE 》|
  cput r (n'.+1 * fact n' * a) >> Ret tt
  |《 over 》|
  cget r >>= (fun s : coq_type N ml_int => cput r (n'.+1 * fact n' * s) >> Ret tt)

       \end{minted}
  \fi
  \caption{proof of factn if n =  n' + 1 }
\end{figure}

\iffalse
  \begin{minted}[escapeinside=||]{ssr}
 Definition factn_aux (n: nat) (r : loc ml_int) :=
 do s <- cget r;
 do _ <- cput r (fact n * s); @ret M _ tt.
 
 Lemma factE_aux (n: nat) (r : loc ml_int): factdts_aux n r |\scalebox{0.8}{$\approx$}| factn_aux n r.
 
 | case : (n = 0) |
 while (factdts_aux_body r) 0
 |《 fixpointE 》|
 cget r >>=
 (fun x : coq_type N ml_int =>
  (cput r x >> Ret (inl tt)) >>=
  sum_rect (fun=> M unit) Ret (while (factdts_aux_body r)))
  |《 rewrite under cget r >>= by bindfwB》|
  (cput r s >> Ret (inl tt)) >>= sum_rect (fun=> M unit) Ret (while (factdts_aux_body r))
  |《 fixpointE 》|
  cput r (1 * s) >> Ret tt
  |《 over 》|
  cget r >>= (fun s : coq_type N ml_int => cput r (1 * s) >> Ret tt)

 | case : (n = n' + 1) |
 while (factdts_aux_body r) n'.+1
 |《 fixpointE 》|
 cget r >>=
 (fun x : coq_type N ml_int =>
  (cput r (n'.+1 * x) >> Ret (inr n')) >>=
  sum_rect (fun=> M unit) Ret (while (factdts_aux_body r)))
  |《 rewrite under cget r >>= by bindfwB 》|
  (cput r (n'.+1 * a) >> Ret (inr n')) >>=
  sum_rect (fun=> M unit) Ret (while (factdts_aux_body r))
  |《 fixpointE 》|
  cput r (n'.+1 * a) >> (cget r >>= (fun s : coq_type N ml_int => cput r (fact n' * s) >> Ret tt))
  |《 fixpointE 》|
  cput r (n'.+1 * fact n' * a) >> Ret tt
  |《 over 》|
  cget r >>= (fun s : coq_type N ml_int => cput r (n'.+1 * fact n' * s) >> Ret tt)
 \end{minted}

\fi

%長すぎるため、その後の部分は省略する。
\iffalse
  その後、その書き換えとtypedstoremonadの書き換え規則を用いることで、factnに一致することを示した。

  \begin{minted}[escapeinside=||]{ssr}
  Lemma factE n : factdts n |\scalebox{0.8}{$\approx$}| factn n.

  cnew ml_int 1 >>= (fun r : loc ml_int => factdts_aux n r >> (cget r >>= [eta Ret]))
  |《 rewrite under cnew mlint 1 >>= by bindfwB 》|

  factdts_aux n a >> (cget a >>= [eta Ret])
  |《 fixpointE 》|

  |《 rewrite under cnew mlint 1 >>= by bindfwB》|
  factdts_aux n a >> (cget a >>= [eta Ret])
  |《 fixpointE 》|

  cget a >>=
  (fun x : coq_type N ml_int => (cput a (fact n * x) >> Ret tt) >> (cget a >>= [eta Ret]))
  |《 rewrite under cget a >>= by eqbind》|
  (cput a (fact n * x) >> Ret tt) >> (cget a >>= [eta Ret])
  |《 fixpointE 》|
  cput a (fact n * x) >> (cget a >>= [eta Ret])
  |《 over 》|
  cnew ml_int 1 >>=
  (fun a : loc ml_int =>
   cget a >>=
   (fun x : coq_type N ml_int => cput a (fact n * x) >> (cget a >>= [eta Ret])))
   |《 fixpointE 》|
   cnew ml_int (fact n) >>= (fun r : loc ml_int => cget r >>= [eta Ret])

\end{minted}

  \iffalse
    \begin{minted}{ssr}
  |《 rewrite under cnew mlint 1 >>= by bindfwB》|
  factdts_aux n a >> (cget a >>= [eta Ret])
  |《 fixpointE 》|
  cget a >>=
  (fun x : coq_type N ml_int => (cput a (fact n * x) >> Ret tt) >> (cget a >>= [eta Ret]))
  |《 rewrite under cget a >>= by eqbind》|
  (cput a (fact n * x) >> Ret tt) >> (cget a >>= [eta Ret])
  |《 fixpointE 》|
  cput a (fact n * x) >> (cget a >>= [eta Ret])
  |《 over 》|
  cnew ml_int 1 >>=
  (fun a : loc ml_int =>
   cget a >>=
   (fun x : coq_type N ml_int => cput a (fact n * x) >> (cget a >>= [eta Ret])))
   |《 fixpointE 》|
   cnew ml_int (fact n) >>= (fun r : loc ml_int => cget r >>= [eta Ret])

\end{minted}
  \fi

  \iffalse
    |《 rewrite under cnew ml_int 1 >>= by bindfwB》|
    factdts_aux n a >> (cget a >>= [eta Ret])
    |《 fixpointE 》|
    cget a >>=
    (fun x : coq_type N ml_int => (cput a (fact n * x) >> Ret tt) >> (cget a >>= [eta Ret]))
    |《 rewrite under cget a >>= by eq_bind》|
    (cput a (fact n * x) >> Ret tt) >> (cget a >>= [eta Ret])
    |《 fixpointE 》|
    cput a (fact n * x) >> (cget a >>= [eta Ret])
    |《 over 》|
    cnew ml_int 1 >>=
    (fun a : loc ml_int =>
    cget a >>=
    (fun x : coq_type N ml_int => cput a (fact n * x) >> (cget a >>= [eta Ret])))
    |《 fixpointE 》|
    cnew ml_int (fact n) >>= (fun r : loc ml_int => cget r >>= [eta Ret])

  \fi
\fi

\section{関連研究}
\subsection{一般再帰関数に対するCoq上での検証}
\cite{ddd}は、coinductive typeを用いて定義されたデータ構造ITreeを用いて
インタラクションのある一般再帰関数を表現している。この手法では、それぞれの副作用をイベントとしてITreeに埋め込み、
ITreeの間の弱双模倣性を満たす等価関係を定義することでプログラムの検証を可能にしている。
またそれに関連して
%(An Equational Theory for Weak Bisimulation )
\cite{ddd}では、pakoを拡張したgpacoを用いることで
弱双模倣性に関する等式論理をCoqで実装している。

%(free monadを使った手法)


\subsection{Elgotモナドに関する理論}
本研究でDelayモナドのインターフェイスを定義する際に参考にしたcomplete elgot モナドは、
%(iteration theories)
\cite{ddd}で提唱された再帰構造に関する代数理論であるiteration theoryに対応するものである。
Complete elgot monadに関する理論的研究としては、
%(Pir´og and Gibbon [PG13], and Sergey, Christoph, and Lutz [GSRJ18] )
\cite{ddd}が、Compete elogit monadの構造が
いくつかのモナドトランスフォーマーにより保たれることを示している。また、
%(Simpson and Plotkin [SP00])
\cite{ddd}はiteration theoryの公理が完全であることを示している。
したがって本研究で用いたインターフェイスは、十分な検証能力を持つと考えている。



\section{まとめと今後の課題}
本研究より、Delayモナドを通じてMonaeで一般再帰関数を扱うことができるようになった。
等価関係に基づく変形による一般再帰関数の検証の利点はとしては、まずcoinductionによる証明をする必要がないことである。
Coqではcoinductive typeを用いて直接一般再帰関数を表すことが可能ではあるが、検証には余帰納法が不可欠となる。
その際、Coqではガード制約というコンストラクタと余再帰呼び出しに関する構文的制約を満たす必要があり、証明が難しくなる。
一方、等価関係に基づく変形では、そのような難しさは生じず、直感的で簡潔な証明が可能になる。
次に、他の副作用との組み合わせが容易であることもわかった。
本研究で取り上げたように、再帰構造をモナドを用いて表現することで、モナドトランスフォーマーによる
状態モナドや例外モナドとの組み合わせを容易に行うことが可能である。インターフェイスにオペレーターや規則を追加することで他の副作用とも組み合わせることができると期待している。
また、これまでのMonaeでの検証では等式変形による検証のみ扱っていたが、setoidライブラリを用いることで、等価関係に基づく変形による検証
もこれまでと同様にrewrite タクティクスを中心とした証明により行うことが可能であることがわかった。\\
今後の課題としては以下のようなものがある。


\begin{enumerate}
  %公理の完全性について触れる？関連研究で触れるか
  %本当にむずい？確率もなどとの組み合わせ。
  \item 他のモナドとの組み合わせ\\
        今回の研究では、モナドトランスフォーマーによるモナドの組み合わせしか取り扱っていないが、モナディック等式変形では、
        インターフェイスに異なるモナドのオペレーターとその間の等式を追加することで、複数の副作用を持つプログラムに関する
        検証を可能にしている。特にモナドトランスフォーマーによる組み合わせが難しい確率モナドや非決定性モナドなどとの組み合わせが
        可能かどうかが課題である。


  \item 一般的な双模倣性に関するMonaeでの検証\\
        今回の研究で用いた計算的同値性は、Delay A上の弱双模倣性を満たす関係である。一方で一般的な双模倣性に関する等価性変形を
        行うことで、並行プログラムやStreamなどの無限の長さも持ちうるデータを扱うプログラムに関する検証が期待できる。
        そのような一般的な双模倣性に関する性質を持つモナドのインターフェイスをどのように定義するか、またその健全性をどのように示すか
        が課題である。
        %dependent type assertion (Towards a Practical Library for Monadic Equational Reasoning in Coq)の内容を盛り込む
  \item プログラムの部分正当性の検証\\
        現在、プログラムの実行後の状態について検証するには、factauxEで行ったように整礎関係を見つけ出し、その関係に関する
        帰納法を行う必要がある。つまり、実質的にプログラムの停止性を示す必要があり、ホーア論理で行うようなループ不変条件を用いた
        検証を行うことができない。したがって、ループ不変条件を用いた部分正当性の検証をどのように等式変形の枠組みで導入するかが
        課題である。
\end{enumerate}







\end{document}
